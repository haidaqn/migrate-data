const { MongoClient } = require('mongodb');
const sql = require('mssql');
const { performance } = require('perf_hooks');
const { v7: uuidv7 } = require('uuid');

const mongoUrl = 'mongodb://localhost:27017';
const dbName = 'ids_sensor';
const collectionName = 'sensordatas';
const BATCH_SIZE = 1000;

const sqlConfig = {
    server: 'localhost',
    port: 1433,
    database: 'qlmt_test', 
    user: 'sa',
    password: 'StrongPassword123!', 
    options: {
        encrypt: false,
        trustServerCertificate: true,
        enableArithAbort: true
    }
};


async function connectSQLServer() {
    try {
      console.log('üîÑ Th·ª≠ k·∫øt n·ªëi v·ªõi SQL Server...');
      
      // Th·ª≠ k·∫øt n·ªëi ƒë·∫øn master database tr∆∞·ªõc
      const masterConfig = {
        server: sqlConfig.server,
        port: sqlConfig.port,
        user: sqlConfig.user,
        password: sqlConfig.password,
        database: 'master', // K·∫øt n·ªëi ƒë·∫øn master database tr∆∞·ªõc
        options: {
          encrypt: false,
          trustServerCertificate: true,
          enableArithAbort: true
        }
      };
      
      await sql.connect(masterConfig);
      console.log('‚úÖ K·∫øt n·ªëi ƒë·∫øn SQL Server th√†nh c√¥ng (master database)');
      
      return sql;
    } catch (err) {
      console.error('‚ùå L·ªói k·∫øt n·ªëi SQL Server:', err);
      throw err;
    }
  }


async function setupDatabase() {
  try {
    // T·∫°o database n·∫øu ch∆∞a t·ªìn t·∫°i
    await sql.query`
      IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'qlmt_test')
      BEGIN
        CREATE DATABASE qlmt_test;
      END
    `;
    
    // Chuy·ªÉn sang s·ª≠ d·ª•ng database qlmt_test
    await sql.query`USE qlmt_test`;
    
    // T·∫°o b·∫£ng n·∫øu ch∆∞a t·ªìn t·∫°i
    await sql.query`
      IF NOT EXISTS (SELECT * FROM sys.tables WHERE name = 'sensorsdata')
      BEGIN
        CREATE TABLE sensorsdata (
          _id VARCHAR(36) PRIMARY KEY,
          sensor VARCHAR(255),
          zone VARCHAR(255),
          value INT,
          timeReceived DATETIME NULL,
          minute INT,
          hour INT,
          day INT,
          month INT,
          year INT,
          createdAt DATETIME NULL,
          updatedAt DATETIME NULL
        );
        
        CREATE INDEX idx_sensor ON sensorsdata(sensor);
        CREATE INDEX idx_zone ON sensorsdata(zone);
        CREATE INDEX idx_time ON sensorsdata(year, month, day, hour, minute);
      END
    `;
    
    console.log('‚úÖ ƒê√£ thi·∫øt l·∫≠p database v√† table');
  } catch (error) {
    console.error('‚ùå L·ªói khi thi·∫øt l·∫≠p database:', error);
    throw error;
  }
}

// X·ª≠ l√Ω d·ªØ li·ªáu t·ª´ MongoDB
function transformMongoItem(item) {
  return {
    _id: uuidv7(),
    sensor: item.sensor || null,
    zone: item.zone || null,
    value: item.value || 0,
    timeReceived: item.timeReceived ? new Date(item.timeReceived.$date || item.timeReceived) : null,
    minute: item.minute || 0,
    hour: item.hour || 0,
    day: item.day || 0,
    month: item.month || 0,
    year: item.year || 0,
    createdAt: item.createdAt ? new Date(item.createdAt.$date || item.createdAt) : null,
    updatedAt: item.updatedAt ? new Date(item.updatedAt.$date || item.updatedAt) : null
  };
}

async function migrateData() {
  const startTime = performance.now();
  let totalProcessed = 0;
  let totalBatches = 0;
  
  try {
    const mongoClient = new MongoClient(mongoUrl, { 
      useNewUrlParser: true, 
      useUnifiedTopology: true,
      maxPoolSize: 10
    });
    
    await mongoClient.connect();
    console.log('‚úÖ K·∫øt n·ªëi MongoDB th√†nh c√¥ng');
    
    const db = mongoClient.db(dbName);
    const collection = db.collection(collectionName);
    
    const totalDocuments = await collection.countDocuments();
    console.log(`üîç T·ªïng s·ªë d√≤ng c·∫ßn migrate: ${totalDocuments}`);
    
    const cursor = collection.find({}).batchSize(BATCH_SIZE);
    let batch = [];
    
    while (await cursor.hasNext()) {
      const item = await cursor.next();
      const newItem = transformMongoItem(item);
      batch.push(newItem);
      
      // Insert theo batch khi ƒë·ªß k√≠ch th∆∞·ªõc
      if (batch.length >= BATCH_SIZE) {
        await insertBatch(batch);
        totalProcessed += batch.length;
        totalBatches++;
        
        const progress = (totalProcessed / totalDocuments * 100).toFixed(2);
        const elapsedTime = ((performance.now() - startTime) / 1000).toFixed(2);
        console.log(`‚è±Ô∏è ${progress}% ho√†n th√†nh (${totalProcessed}/${totalDocuments}) - ${elapsedTime}s`);
        
        batch = [];
      }
    }
    
    if (batch.length > 0) {
      await insertBatch(batch);
      totalProcessed += batch.length;
      totalBatches++;
    }
    
    const totalTime = ((performance.now() - startTime) / 1000).toFixed(2);
    console.log(`üéâ Migration ho√†n t·∫•t! ƒê√£ x·ª≠ l√Ω ${totalProcessed} d√≤ng trong ${totalTime} gi√¢y (${totalBatches} batches)`);
    await mongoClient.close();
  } catch (error) {
    console.error('‚ùå L·ªói khi migrate d·ªØ li·ªáu:', error);
    throw error;
  }
}

async function insertBatch(batch) {
  try {
    // S·ª≠ d·ª•ng ƒë·ªëi t∆∞·ª£ng Transaction ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh to√†n v·∫πn
    const transaction = new sql.Transaction();
    
    await new Promise((resolve, reject) => {
      transaction.begin(err => {
        if (err) {
          reject(err);
          return;
        }
        
        // T·∫°o request m·ªõi trong transaction
        const request = new sql.Request(transaction);
        
        // T·∫°o table variable
        const table = new sql.Table('sensorsdata');
        table.create = false;
        table.columns.add('_id', sql.VarChar(36), { nullable: false });
        table.columns.add('sensor', sql.VarChar(255), { nullable: true });
        table.columns.add('zone', sql.VarChar(255), { nullable: true });
        table.columns.add('value', sql.Int, { nullable: true });
        table.columns.add('timeReceived', sql.DateTime, { nullable: true });
        table.columns.add('minute', sql.Int, { nullable: true });
        table.columns.add('hour', sql.Int, { nullable: true });
        table.columns.add('day', sql.Int, { nullable: true });
        table.columns.add('month', sql.Int, { nullable: true });
        table.columns.add('year', sql.Int, { nullable: true });
        table.columns.add('createdAt', sql.DateTime, { nullable: true });
        table.columns.add('updatedAt', sql.DateTime, { nullable: true });
        
        // Th√™m d·ªØ li·ªáu v√†o b·∫£ng t·∫°m
        batch.forEach(item => {
          table.rows.add(
            item._id,
            item.sensor,
            item.zone,
            item.value,
            item.timeReceived,
            item.minute,
            item.hour,
            item.day,
            item.month,
            item.year,
            item.createdAt,
            item.updatedAt
          );
        });
        
        // Th·ª±c hi·ªán bulk insert
        request.bulk(table, (err, result) => {
          if (err) {
            transaction.rollback(rollbackErr => {
              reject(err); // Reject v·ªõi l·ªói g·ªëc
            });
          } else {
            transaction.commit(commitErr => {
              if (commitErr) {
                reject(commitErr);
              } else {
                resolve(result);
              }
            });
          }
        });
      });
    });
    
  } catch (error) {
    console.error(`‚ùå L·ªói khi insert batch (${batch.length} d√≤ng):`, error.message);
    
    // N·∫øu batch l·ªõn b·ªã l·ªói, chia nh·ªè v√† th·ª≠ l·∫°i
    if (batch.length > 1) {
      console.log(`‚Ü™Ô∏è Chia nh·ªè batch (${batch.length} d√≤ng) v√† th·ª≠ l·∫°i...`);
      const halfSize = Math.ceil(batch.length / 2);
      const firstHalf = batch.slice(0, halfSize);
      const secondHalf = batch.slice(halfSize);
      
      try {
        await insertBatch(firstHalf);
        await insertBatch(secondHalf);
        console.log(`‚úÖ ƒê√£ x·ª≠ l√Ω th√†nh c√¥ng sau khi chia nh·ªè`);
      } catch (subError) {
        console.error(`‚ùå Kh√¥ng th·ªÉ x·ª≠ l√Ω sau khi chia nh·ªè:`, subError.message);
        throw subError;
      }
    } else {
      console.error(`‚ùå B·ªè qua d√≤ng c√≥ l·ªói:`, JSON.stringify(batch[0]));
    }
  }
}

// Thay th·∫ø h√†m setupMergeOperation ƒë·ªÉ h·ªó tr·ª£ t·ªët h∆°n v·ªõi SQL Server c∆° b·∫£n
async function setupMergeOperation() {
  try {
    // Ki·ªÉm tra version c·ªßa SQL Server v√† ƒëi·ªÅu ch·ªânh t√≠nh nƒÉng h·ªó tr·ª£
    const versionResult = await sql.query`SELECT @@VERSION as version`;
    const sqlVersion = versionResult.recordset[0].version;
    console.log(`üìä SQL Server Version: ${sqlVersion}`);
    
    // N·∫øu SQL Server h·ªó tr·ª£ MERGE statement (SQL Server 2008+)
    if (sqlVersion.includes('SQL Server')) {
      // T·∫°o stored procedure ƒë·ªÉ x·ª≠ l√Ω upsert
      await sql.query`
        IF NOT EXISTS (SELECT * FROM sys.procedures WHERE name = 'UpsertSensorData')
        BEGIN
          EXEC('
            CREATE PROCEDURE UpsertSensorData
              @id VARCHAR(36),
              @sensor VARCHAR(255),
              @zone VARCHAR(255), 
              @value INT,
              @timeReceived DATETIME,
              @minute INT,
              @hour INT,
              @day INT,
              @month INT,
              @year INT,
              @createdAt DATETIME,
              @updatedAt DATETIME
            AS
            BEGIN
              SET NOCOUNT ON;
              
              IF EXISTS (SELECT 1 FROM sensorsdata WHERE _id = @id)
              BEGIN
                UPDATE sensorsdata SET
                  sensor = @sensor,
                  zone = @zone,
                  value = @value
                WHERE _id = @id
              END
              ELSE
              BEGIN
                INSERT INTO sensorsdata (_id, sensor, zone, value, timeReceived, minute, hour, day, month, year, createdAt, updatedAt)
                VALUES (@id, @sensor, @zone, @value, @timeReceived, @minute, @hour, @day, @month, @year, @createdAt, @updatedAt)
              END
            END
          ')
        END
      `;
      
      console.log('‚úÖ ƒê√£ t·∫°o stored procedure cho upsert');
    } else {
      console.log('‚ö†Ô∏è SQL Server c√≥ th·ªÉ kh√¥ng h·ªó tr·ª£ ƒë·∫ßy ƒë·ªß MERGE, s·∫Ω s·ª≠ d·ª•ng insert tr·ª±c ti·∫øp');
    }
  } catch (error) {
    console.error('‚ö†Ô∏è L·ªói khi t·∫°o stored procedure, ti·∫øp t·ª•c v·ªõi insert tr·ª±c ti·∫øp:', error);
    // Kh√¥ng throw error ƒë·ªÉ ti·∫øp t·ª•c qu√° tr√¨nh
  }
}

(async () => {
  try {
    console.log('üöÄ B·∫Øt ƒë·∫ßu qu√° tr√¨nh migrate...');
    await connectSQLServer();
    await setupDatabase();
    await setupMergeOperation();
    await migrateData();
  } catch (error) {
    console.error('‚ùå L·ªói ch√≠nh:', error);
  } finally {
    if (sql.connected) {
      await sql.close();
      console.log('üëã ƒê√£ ƒë√≥ng k·∫øt n·ªëi SQL Server');
    }
  }
})();